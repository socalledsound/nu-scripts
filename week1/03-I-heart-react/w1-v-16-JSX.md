https://reactjs.org/docs/jsx-in-depth.html
https://reactjs.org/docs/react-without-jsx.html
https://reacttraining.com/blog/jsx-the-confusing-parts/

might be a little long?

[SC]
JSX
[VO]

In the last video, you saw that our App is wrapped in JSX when we pass it in to ReactDOM.render(), and I mentioned that JSX is a 'syntax extension for javascript'.

And you learned that the scaffolding set up by create react app -- notably the Babel compiler -- interprets that syntax and turns it into javascript that will return a React element, the elements that are the nodes that make up the virtual DOM tree.

JSX is, essentially, a shorthand notation for writing the javascript which we'll use to create our web page. And it looks a lot like HTML, which is nice, and really simplifies our lives as developers.

It's tremendously useful and, once you get used to it, it's a great way to write web pages!

IN this video, I'll go over a few of the key features of JSX.

[SC]
show app component
[VO]
Open up the App component that was auto-generated by the CRA script in your vs code editor.

[SC]

    import logo from './logo.svg';
    import './App.css';

[VO]
At the top are our imports. Remember how I said, a few videos ago, that you can import images in a javascript app? Here, we're importing an svg file, which we then display on our page, and, just like our index.js file, we're also importing some css.

# maybe include this maybe not

There's also another hidden import happening here:
import React from 'react.
In older code, you used to need to

[SC]
app function
[VO]

Then, below, is our App function. And you can see that it's just basically one big return statement, which returns a farily large block of JSX.

This is called a 'stateless functional React component' and it's a great way to write React components. We can write these functions using the function keyword, or as arrow functions. We'll mostly write them as arrow functions in this course, but either way works.

Perhaps the most import thing about these functions is that, in order to be valid React components, they must return one and only one html element. So if you want to have more than one bit of content, you need to wrap all of the bits of your content in a parent component. Here, our app is returning a single div, that contains a header, which in turn contains an image, some text, and a link.

[SC]

<div >

[VO]

Each of these html looking things are React elements, nodes on our virtual dom tree. These nodes get bundled together in our App, and then we pass them into the ReactDOM.render function and that render function decides how to update and build our web page as efficiently as possible.

[SC]
React.createElement('div', null, null)
[VO]
As I briefly mentioned in the last video, each of these elements, when it is transpiled into javascript, will actually look something like this.

But what about these null values?

[SC]
createElement('div',{className: 'circle'}, [])
[VO]
Remember the 'props' object we had in our own createElement function in 'react without react'?

That was modeled on the way React elements work.

[SC]

    <div className="circle">

[VO]

We can pass arguments into these elemental functions, which we call 'props' using a syntax that's a lot like vanilla DOM manipulation, just more succinct. We can assign a class name, which will take advantage of classes that are declared in a css file that we've imported.

[SC]

     <img src={logo} className="App-logo" alt="logo" />

[VO]
And all of the other properties that are traditionally available on a DOM node are also available on a React element.

Here, we've got props for not just className but all of the other things we like to pass in to images, like a source and also an alt tag.

[SC]

     <img src={logo} className="App-logo" alt="logo" />

[VO]
But pay particular attention to the src tag!

One of the really neat things about JSX is that we can use javascript variables and expressions in JSX, if we wrap them in curly braces.

[SC]

    function App() {
    return (
    );
    }
